{"version":3,"sources":["deferred.js"],"names":["define","$","Deferred","func","tuples","Callbacks","once","memory","state","promise","always","deferred","done","arguments","fail","this","then","fns","defer","each","i","tuple","fn","isFunction","returned","apply","resolve","reject","progress","notify","context","values","obj","extend","pipe","list","stateString","add","disable","lock","fireWith","call","slice","Array","prototype","when","sub","progressValues","progressContexts","resolveContexts","resolveValues","len","length","remain","updateFn","ctx","val","value","notifyWith","resolveWith"],"mappings":";;;;;;;AAAAA,QACI,UACD,SAASC,GAiBR,QAASC,GAASC,GACd,GAAIC,KAEK,UAAW,OAAQH,EAAEI,WAAYC,KAAM,EAAGC,OAAQ,IAAM,aACxD,SAAU,OAAQN,EAAEI,WAAYC,KAAM,EAAGC,OAAQ,IAAM,aACvD,SAAU,WAAYN,EAAEI,WAAYE,OAAQ,MAEjDC,EAAQ,UACRC,GACID,MAAO,WACH,MAAOA,IAEXE,OAAQ,WAEJ,MADAC,GAASC,KAAKC,WAAWC,KAAKD,WACvBE,MAEXC,KAAM,WACF,GAAIC,GAAMJ,SACV,OAAOX,GAAS,SAASgB,GACrBjB,EAAEkB,KAAKf,EAAQ,SAASgB,EAAGC,GACvB,GAAIC,GAAKrB,EAAEsB,WAAWN,EAAIG,KAAOH,EAAIG,EACrCT,GAASU,EAAM,IAAI,WACf,GAAIG,GAAWF,GAAMA,EAAGG,MAAMV,KAAMF,UACpC,IAAIW,GAAYvB,EAAEsB,WAAWC,EAASf,SAClCe,EAASf,UACJG,KAAKM,EAAMQ,SACXZ,KAAKI,EAAMS,QACXC,SAASV,EAAMW,YACjB,CACH,GAAIC,GAAUf,OAASN,EAAUS,EAAMT,UAAYM,KAC/CgB,EAAST,GAAME,GAAYX,SAC/BK,GAAMG,EAAM,GAAK,QAAQS,EAASC,QAI9Cd,EAAM,OACPR,WAGPA,QAAS,SAASuB,GACd,MAAc,OAAPA,EAAc/B,EAAEgC,OAAOD,EAAKvB,GAAWA,IAGtDE,IAyBJ,OAvBAF,GAAQyB,KAAOzB,EAAQO,KAEvBf,EAAEkB,KAAKf,EAAQ,SAASgB,EAAGC,GACvB,GAAIc,GAAOd,EAAM,GACbe,EAAcf,EAAM,EAExBZ,GAAQY,EAAM,IAAMc,EAAKE,IAErBD,GACAD,EAAKE,IAAI,WACL7B,EAAQ4B,GACThC,EAAW,EAAJgB,GAAO,GAAGkB,QAASlC,EAAO,GAAG,GAAGmC,MAG9C5B,EAASU,EAAM,IAAM,WAEjB,MADAV,GAASU,EAAM,GAAK,QAAQN,OAASJ,EAAWF,EAAUM,KAAMF,WACzDE,MAEXJ,EAASU,EAAM,GAAK,QAAUc,EAAKK,WAGvC/B,EAAQA,QAAQE,GACZR,GAAMA,EAAKsC,KAAK9B,EAAUA,GACvBA,EAtEX,GAAI+B,GAAQC,MAAMC,UAAUF,KAiH5B,OAxCAzC,GAAE4C,KAAO,SAASC,GACd,GAKIC,GAAgBC,EAAkBC,EALlCC,EAAgBR,EAAMD,KAAK5B,WAC3BsC,EAAMD,EAAcE,OACpBhC,EAAI,EACJiC,EAAiB,IAARF,GAAcL,GAAO7C,EAAEsB,WAAWuB,EAAIrC,SAAY0C,EAAM,EACjExC,EAAsB,IAAX0C,EAAeP,EAAM5C,IAEhCoD,EAAW,SAASlC,EAAGmC,EAAKC,GACxB,MAAO,UAASC,GACZF,EAAInC,GAAKL,KACTyC,EAAIpC,GAAKP,UAAUuC,OAAS,EAAIV,EAAMD,KAAK5B,WAAa4C,EACpDD,IAAQT,EACRpC,EAAS+C,WAAWH,EAAKC,KACdH,GACX1C,EAASgD,YAAYJ,EAAKC,IAK1C,IAAIL,EAAM,EAIN,IAHAJ,EAAiB,GAAIJ,OAAMQ,GAC3BH,EAAmB,GAAIL,OAAMQ,GAC7BF,EAAkB,GAAIN,OAAMQ,GACrB/B,EAAI+B,IAAO/B,EACV8B,EAAc9B,IAAMnB,EAAEsB,WAAW2B,EAAc9B,GAAGX,SAClDyC,EAAc9B,GAAGX,UACZG,KAAK0C,EAASlC,EAAG6B,EAAiBC,IAClCpC,KAAKH,EAASgB,QACdC,SAAS0B,EAASlC,EAAG4B,EAAkBD,MAE1CM,CAKd,OADKA,IAAQ1C,EAASgD,YAAYV,EAAiBC,GAC5CvC,EAASF,WAGpBR,EAAEC,SAAWA,EAEND","file":"../deferred.js","sourcesContent":["define([\r\n    \"./core\"\r\n], function($) {\r\n\r\n    /*\r\n        (function ($) {\r\n            $.Deferred = async.Deferred;\r\n            $.when = async.when;\r\n        })(Zepto);\r\n    */\r\n\r\n    //     This module is borrow from zepto.deferred.js\r\n    //     (c) 2010-2014 Thomas Fuchs\r\n    //     Zepto.js may be freely distributed under the MIT license.\r\n    //\r\n    //     Some code (c) 2005, 2013 jQuery Foundation, Inc. and other contributors\r\n\r\n    var slice = Array.prototype.slice\r\n\r\n    function Deferred(func) {\r\n        var tuples = [\r\n                // action, add listener, listener list, final state\r\n                [\"resolve\", \"done\", $.Callbacks({ once: 1, memory: 1 }), \"resolved\"],\r\n                [\"reject\", \"fail\", $.Callbacks({ once: 1, memory: 1 }), \"rejected\"],\r\n                [\"notify\", \"progress\", $.Callbacks({ memory: 1 })]\r\n            ],\r\n            state = \"pending\",\r\n            promise = {\r\n                state: function() {\r\n                    return state\r\n                },\r\n                always: function() {\r\n                    deferred.done(arguments).fail(arguments)\r\n                    return this\r\n                },\r\n                then: function( /* fnDone [, fnFailed [, fnProgress]] */ ) {\r\n                    var fns = arguments\r\n                    return Deferred(function(defer) {\r\n                        $.each(tuples, function(i, tuple) {\r\n                            var fn = $.isFunction(fns[i]) && fns[i]\r\n                            deferred[tuple[1]](function() {\r\n                                var returned = fn && fn.apply(this, arguments)\r\n                                if (returned && $.isFunction(returned.promise)) {\r\n                                    returned.promise()\r\n                                        .done(defer.resolve)\r\n                                        .fail(defer.reject)\r\n                                        .progress(defer.notify)\r\n                                } else {\r\n                                    var context = this === promise ? defer.promise() : this,\r\n                                        values = fn ? [returned] : arguments\r\n                                    defer[tuple[0] + \"With\"](context, values)\r\n                                }\r\n                            })\r\n                        })\r\n                        fns = null\r\n                    }).promise()\r\n                },\r\n\r\n                promise: function(obj) {\r\n                    return obj != null ? $.extend(obj, promise) : promise\r\n                }\r\n            },\r\n            deferred = {};\r\n\r\n        promise.pipe = promise.then;\r\n\r\n        $.each(tuples, function(i, tuple) {\r\n            var list = tuple[2],\r\n                stateString = tuple[3]\r\n\r\n            promise[tuple[1]] = list.add\r\n\r\n            if (stateString) {\r\n                list.add(function() {\r\n                    state = stateString\r\n                }, tuples[i ^ 1][2].disable, tuples[2][2].lock)\r\n            }\r\n\r\n            deferred[tuple[0]] = function() {\r\n                deferred[tuple[0] + \"With\"](this === deferred ? promise : this, arguments)\r\n                return this\r\n            }\r\n            deferred[tuple[0] + \"With\"] = list.fireWith\r\n        })\r\n\r\n        promise.promise(deferred)\r\n        if (func) func.call(deferred, deferred)\r\n        return deferred\r\n    }\r\n\r\n    $.when = function(sub) {\r\n        var resolveValues = slice.call(arguments),\r\n            len = resolveValues.length,\r\n            i = 0,\r\n            remain = len !== 1 || (sub && $.isFunction(sub.promise)) ? len : 0,\r\n            deferred = remain === 1 ? sub : Deferred(),\r\n            progressValues, progressContexts, resolveContexts,\r\n            updateFn = function(i, ctx, val) {\r\n                return function(value) {\r\n                    ctx[i] = this\r\n                    val[i] = arguments.length > 1 ? slice.call(arguments) : value\r\n                    if (val === progressValues) {\r\n                        deferred.notifyWith(ctx, val)\r\n                    } else if (!(--remain)) {\r\n                        deferred.resolveWith(ctx, val)\r\n                    }\r\n                }\r\n            }\r\n\r\n        if (len > 1) {\r\n            progressValues = new Array(len)\r\n            progressContexts = new Array(len)\r\n            resolveContexts = new Array(len)\r\n            for (; i < len; ++i) {\r\n                if (resolveValues[i] && $.isFunction(resolveValues[i].promise)) {\r\n                    resolveValues[i].promise()\r\n                        .done(updateFn(i, resolveContexts, resolveValues))\r\n                        .fail(deferred.reject)\r\n                        .progress(updateFn(i, progressContexts, progressValues))\r\n                } else {\r\n                    --remain\r\n                }\r\n            }\r\n        }\r\n        if (!remain) deferred.resolveWith(resolveContexts, resolveValues)\r\n        return deferred.promise()\r\n    }\r\n\r\n    $.Deferred = Deferred\r\n\r\n    return $;\r\n\r\n});\r\n"]}