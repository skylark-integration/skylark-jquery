{"version":3,"sources":["deferred.js"],"names":["define","$","Deferred","func","tuples","Callbacks","once","memory","state","promise","always","deferred","done","arguments","fail","this","then","fns","defer","each","i","tuple","fn","isFunction","returned","apply","resolve","reject","progress","notify","context","values","obj","extend","list","stateString","add","disable","lock","fireWith","call","slice","Array","prototype","when","sub","progressValues","progressContexts","resolveContexts","resolveValues","len","length","remain","updateFn","ctx","val","value","notifyWith","resolveWith"],"mappings":";;;;;;;AAAAA,QACI,UACD,SAASC,GAiBR,QAASC,GAASC,GACd,GAAIC,KAEK,UAAW,OAAQH,EAAEI,WAAYC,KAAM,EAAGC,OAAQ,IAAM,aACxD,SAAU,OAAQN,EAAEI,WAAYC,KAAM,EAAGC,OAAQ,IAAM,aACvD,SAAU,WAAYN,EAAEI,WAAYE,OAAQ,MAEjDC,EAAQ,UACRC,GACID,MAAO,WACH,MAAOA,IAEXE,OAAQ,WAEJ,MADAC,GAASC,KAAKC,WAAWC,KAAKD,WACvBE,MAEXC,KAAM,WACF,GAAIC,GAAMJ,SACV,OAAOX,GAAS,SAASgB,GACrBjB,EAAEkB,KAAKf,EAAQ,SAASgB,EAAGC,GACvB,GAAIC,GAAKrB,EAAEsB,WAAWN,EAAIG,KAAOH,EAAIG,EACrCT,GAASU,EAAM,IAAI,WACf,GAAIG,GAAWF,GAAMA,EAAGG,MAAMV,KAAMF,UACpC,IAAIW,GAAYvB,EAAEsB,WAAWC,EAASf,SAClCe,EAASf,UACJG,KAAKM,EAAMQ,SACXZ,KAAKI,EAAMS,QACXC,SAASV,EAAMW,YACjB,CACH,GAAIC,GAAUf,OAASN,EAAUS,EAAMT,UAAYM,KAC/CgB,EAAST,GAAME,GAAYX,SAC/BK,GAAMG,EAAM,GAAK,QAAQS,EAASC,QAI9Cd,EAAM,OACPR,WAGPA,QAAS,SAASuB,GACd,MAAc,OAAPA,EAAc/B,EAAEgC,OAAOD,EAAKvB,GAAWA,IAGtDE,IAuBJ,OArBAV,GAAEkB,KAAKf,EAAQ,SAASgB,EAAGC,GACvB,GAAIa,GAAOb,EAAM,GACbc,EAAcd,EAAM,EAExBZ,GAAQY,EAAM,IAAMa,EAAKE,IAErBD,GACAD,EAAKE,IAAI,WACL5B,EAAQ2B,GACT/B,EAAW,EAAJgB,GAAO,GAAGiB,QAASjC,EAAO,GAAG,GAAGkC,MAG9C3B,EAASU,EAAM,IAAM,WAEjB,MADAV,GAASU,EAAM,GAAK,QAAQN,OAASJ,EAAWF,EAAUM,KAAMF,WACzDE,MAEXJ,EAASU,EAAM,GAAK,QAAUa,EAAKK,WAGvC9B,EAAQA,QAAQE,GACZR,GAAMA,EAAKqC,KAAK7B,EAAUA,GACvBA,EApEX,GAAI8B,GAAQC,MAAMC,UAAUF,KA+G5B,OAxCAxC,GAAE2C,KAAO,SAASC,GACd,GAKIC,GAAgBC,EAAkBC,EALlCC,EAAgBR,EAAMD,KAAK3B,WAC3BqC,EAAMD,EAAcE,OACpB/B,EAAI,EACJgC,EAAiB,IAARF,GAAcL,GAAO5C,EAAEsB,WAAWsB,EAAIpC,SAAYyC,EAAM,EACjEvC,EAAsB,IAAXyC,EAAeP,EAAM3C,IAEhCmD,EAAW,SAASjC,EAAGkC,EAAKC,GACxB,MAAO,UAASC,GACZF,EAAIlC,GAAKL,KACTwC,EAAInC,GAAKP,UAAUsC,OAAS,EAAIV,EAAMD,KAAK3B,WAAa2C,EACpDD,IAAQT,EACRnC,EAAS8C,WAAWH,EAAKC,KACdH,GACXzC,EAAS+C,YAAYJ,EAAKC,IAK1C,IAAIL,EAAM,EAIN,IAHAJ,EAAiB,GAAIJ,OAAMQ,GAC3BH,EAAmB,GAAIL,OAAMQ,GAC7BF,EAAkB,GAAIN,OAAMQ,GACrB9B,EAAI8B,IAAO9B,EACV6B,EAAc7B,IAAMnB,EAAEsB,WAAW0B,EAAc7B,GAAGX,SAClDwC,EAAc7B,GAAGX,UACZG,KAAKyC,EAASjC,EAAG4B,EAAiBC,IAClCnC,KAAKH,EAASgB,QACdC,SAASyB,EAASjC,EAAG2B,EAAkBD,MAE1CM,CAKd,OADKA,IAAQzC,EAAS+C,YAAYV,EAAiBC,GAC5CtC,EAASF,WAGpBR,EAAEC,SAAWA,EAEND","file":"../deferred.js","sourcesContent":["define([\n    \"./core\"\n], function($) {\n\n    /*\n        (function ($) {\n            $.Deferred = async.Deferred;\n            $.when = async.when;\n        })(Zepto);\n    */\n\n    //     This module is borrow from zepto.deferred.js\n    //     (c) 2010-2014 Thomas Fuchs\n    //     Zepto.js may be freely distributed under the MIT license.\n    //\n    //     Some code (c) 2005, 2013 jQuery Foundation, Inc. and other contributors\n\n    var slice = Array.prototype.slice\n\n    function Deferred(func) {\n        var tuples = [\n                // action, add listener, listener list, final state\n                [\"resolve\", \"done\", $.Callbacks({ once: 1, memory: 1 }), \"resolved\"],\n                [\"reject\", \"fail\", $.Callbacks({ once: 1, memory: 1 }), \"rejected\"],\n                [\"notify\", \"progress\", $.Callbacks({ memory: 1 })]\n            ],\n            state = \"pending\",\n            promise = {\n                state: function() {\n                    return state\n                },\n                always: function() {\n                    deferred.done(arguments).fail(arguments)\n                    return this\n                },\n                then: function( /* fnDone [, fnFailed [, fnProgress]] */ ) {\n                    var fns = arguments\n                    return Deferred(function(defer) {\n                        $.each(tuples, function(i, tuple) {\n                            var fn = $.isFunction(fns[i]) && fns[i]\n                            deferred[tuple[1]](function() {\n                                var returned = fn && fn.apply(this, arguments)\n                                if (returned && $.isFunction(returned.promise)) {\n                                    returned.promise()\n                                        .done(defer.resolve)\n                                        .fail(defer.reject)\n                                        .progress(defer.notify)\n                                } else {\n                                    var context = this === promise ? defer.promise() : this,\n                                        values = fn ? [returned] : arguments\n                                    defer[tuple[0] + \"With\"](context, values)\n                                }\n                            })\n                        })\n                        fns = null\n                    }).promise()\n                },\n\n                promise: function(obj) {\n                    return obj != null ? $.extend(obj, promise) : promise\n                }\n            },\n            deferred = {}\n\n        $.each(tuples, function(i, tuple) {\n            var list = tuple[2],\n                stateString = tuple[3]\n\n            promise[tuple[1]] = list.add\n\n            if (stateString) {\n                list.add(function() {\n                    state = stateString\n                }, tuples[i ^ 1][2].disable, tuples[2][2].lock)\n            }\n\n            deferred[tuple[0]] = function() {\n                deferred[tuple[0] + \"With\"](this === deferred ? promise : this, arguments)\n                return this\n            }\n            deferred[tuple[0] + \"With\"] = list.fireWith\n        })\n\n        promise.promise(deferred)\n        if (func) func.call(deferred, deferred)\n        return deferred\n    }\n\n    $.when = function(sub) {\n        var resolveValues = slice.call(arguments),\n            len = resolveValues.length,\n            i = 0,\n            remain = len !== 1 || (sub && $.isFunction(sub.promise)) ? len : 0,\n            deferred = remain === 1 ? sub : Deferred(),\n            progressValues, progressContexts, resolveContexts,\n            updateFn = function(i, ctx, val) {\n                return function(value) {\n                    ctx[i] = this\n                    val[i] = arguments.length > 1 ? slice.call(arguments) : value\n                    if (val === progressValues) {\n                        deferred.notifyWith(ctx, val)\n                    } else if (!(--remain)) {\n                        deferred.resolveWith(ctx, val)\n                    }\n                }\n            }\n\n        if (len > 1) {\n            progressValues = new Array(len)\n            progressContexts = new Array(len)\n            resolveContexts = new Array(len)\n            for (; i < len; ++i) {\n                if (resolveValues[i] && $.isFunction(resolveValues[i].promise)) {\n                    resolveValues[i].promise()\n                        .done(updateFn(i, resolveContexts, resolveValues))\n                        .fail(deferred.reject)\n                        .progress(updateFn(i, progressContexts, progressValues))\n                } else {\n                    --remain\n                }\n            }\n        }\n        if (!remain) deferred.resolveWith(resolveContexts, resolveValues)\n        return deferred.promise()\n    }\n\n    $.Deferred = Deferred\n\n    return $;\n\n});\n"]}