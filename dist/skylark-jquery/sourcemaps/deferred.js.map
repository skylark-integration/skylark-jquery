{"version":3,"sources":["deferred.js"],"names":["define","$","Deferred","func","tuples","Callbacks","once","memory","state","promise","always","deferred","done","arguments","fail","this","then","fns","defer","each","i","tuple","fn","isFunction","returned","apply","resolve","reject","progress","notify","context","values","obj","extend","list","stateString","add","disable","lock","fireWith","call","slice","Array","prototype","when","sub","progressValues","progressContexts","resolveContexts","resolveValues","len","length","remain","updateFn","ctx","val","value","notifyWith","resolveWith"],"mappings":";;;;;;;AAAAA,QACI,UACD,SAASC,GAiBR,QAASC,GAASC,GACd,GAAIC,KAEK,UAAW,OAAQH,EAAEI,WAAYC,KAAM,EAAGC,OAAQ,IAAM,aACxD,SAAU,OAAQN,EAAEI,WAAYC,KAAM,EAAGC,OAAQ,IAAM,aACvD,SAAU,WAAYN,EAAEI,WAAYE,OAAQ,MAEjDC,EAAQ,UACRC,GACID,MAAO,WACH,MAAOA,IAEXE,OAAQ,WAEJ,MADAC,GAASC,KAAKC,WAAWC,KAAKD,WACvBE,MAEXC,KAAM,WACF,GAAIC,GAAMJ,SACV,OAAOX,GAAS,SAASgB,GACrBjB,EAAEkB,KAAKf,EAAQ,SAASgB,EAAGC,GACvB,GAAIC,GAAKrB,EAAEsB,WAAWN,EAAIG,KAAOH,EAAIG,EACrCT,GAASU,EAAM,IAAI,WACf,GAAIG,GAAWF,GAAMA,EAAGG,MAAMV,KAAMF,UACpC,IAAIW,GAAYvB,EAAEsB,WAAWC,EAASf,SAClCe,EAASf,UACJG,KAAKM,EAAMQ,SACXZ,KAAKI,EAAMS,QACXC,SAASV,EAAMW,YACjB,CACH,GAAIC,GAAUf,OAASN,EAAUS,EAAMT,UAAYM,KAC/CgB,EAAST,GAAME,GAAYX,SAC/BK,GAAMG,EAAM,GAAK,QAAQS,EAASC,QAI9Cd,EAAM,OACPR,WAGPA,QAAS,SAASuB,GACd,MAAc,OAAPA,EAAc/B,EAAEgC,OAAOD,EAAKvB,GAAWA,IAGtDE,IAuBJ,OArBAV,GAAEkB,KAAKf,EAAQ,SAASgB,EAAGC,GACvB,GAAIa,GAAOb,EAAM,GACbc,EAAcd,EAAM,EAExBZ,GAAQY,EAAM,IAAMa,EAAKE,IAErBD,GACAD,EAAKE,IAAI,WACL5B,EAAQ2B,GACT/B,EAAW,EAAJgB,GAAO,GAAGiB,QAASjC,EAAO,GAAG,GAAGkC,MAG9C3B,EAASU,EAAM,IAAM,WAEjB,MADAV,GAASU,EAAM,GAAK,QAAQN,OAASJ,EAAWF,EAAUM,KAAMF,WACzDE,MAEXJ,EAASU,EAAM,GAAK,QAAUa,EAAKK,WAGvC9B,EAAQA,QAAQE,GACZR,GAAMA,EAAKqC,KAAK7B,EAAUA,GACvBA,EApEX,GAAI8B,GAAQC,MAAMC,UAAUF,KA+G5B,OAxCAxC,GAAE2C,KAAO,SAASC,GACd,GAKIC,GAAgBC,EAAkBC,EALlCC,EAAgBR,EAAMD,KAAK3B,WAC3BqC,EAAMD,EAAcE,OACpB/B,EAAI,EACJgC,EAAiB,IAARF,GAAcL,GAAO5C,EAAEsB,WAAWsB,EAAIpC,SAAYyC,EAAM,EACjEvC,EAAsB,IAAXyC,EAAeP,EAAM3C,IAEhCmD,EAAW,SAASjC,EAAGkC,EAAKC,GACxB,MAAO,UAASC,GACZF,EAAIlC,GAAKL,KACTwC,EAAInC,GAAKP,UAAUsC,OAAS,EAAIV,EAAMD,KAAK3B,WAAa2C,EACpDD,IAAQT,EACRnC,EAAS8C,WAAWH,EAAKC,KACdH,GACXzC,EAAS+C,YAAYJ,EAAKC,IAK1C,IAAIL,EAAM,EAIN,IAHAJ,EAAiB,GAAIJ,OAAMQ,GAC3BH,EAAmB,GAAIL,OAAMQ,GAC7BF,EAAkB,GAAIN,OAAMQ,GACrB9B,EAAI8B,IAAO9B,EACV6B,EAAc7B,IAAMnB,EAAEsB,WAAW0B,EAAc7B,GAAGX,SAClDwC,EAAc7B,GAAGX,UACZG,KAAKyC,EAASjC,EAAG4B,EAAiBC,IAClCnC,KAAKH,EAASgB,QACdC,SAASyB,EAASjC,EAAG2B,EAAkBD,MAE1CM,CAKd,OADKA,IAAQzC,EAAS+C,YAAYV,EAAiBC,GAC5CtC,EAASF,WAGpBR,EAAEC,SAAWA,EAEND","file":"../deferred.js","sourcesContent":["define([\r\n    \"./core\"\r\n], function($) {\r\n\r\n    /*\r\n        (function ($) {\r\n            $.Deferred = async.Deferred;\r\n            $.when = async.when;\r\n        })(Zepto);\r\n    */\r\n\r\n    //     This module is borrow from zepto.deferred.js\r\n    //     (c) 2010-2014 Thomas Fuchs\r\n    //     Zepto.js may be freely distributed under the MIT license.\r\n    //\r\n    //     Some code (c) 2005, 2013 jQuery Foundation, Inc. and other contributors\r\n\r\n    var slice = Array.prototype.slice\r\n\r\n    function Deferred(func) {\r\n        var tuples = [\r\n                // action, add listener, listener list, final state\r\n                [\"resolve\", \"done\", $.Callbacks({ once: 1, memory: 1 }), \"resolved\"],\r\n                [\"reject\", \"fail\", $.Callbacks({ once: 1, memory: 1 }), \"rejected\"],\r\n                [\"notify\", \"progress\", $.Callbacks({ memory: 1 })]\r\n            ],\r\n            state = \"pending\",\r\n            promise = {\r\n                state: function() {\r\n                    return state\r\n                },\r\n                always: function() {\r\n                    deferred.done(arguments).fail(arguments)\r\n                    return this\r\n                },\r\n                then: function( /* fnDone [, fnFailed [, fnProgress]] */ ) {\r\n                    var fns = arguments\r\n                    return Deferred(function(defer) {\r\n                        $.each(tuples, function(i, tuple) {\r\n                            var fn = $.isFunction(fns[i]) && fns[i]\r\n                            deferred[tuple[1]](function() {\r\n                                var returned = fn && fn.apply(this, arguments)\r\n                                if (returned && $.isFunction(returned.promise)) {\r\n                                    returned.promise()\r\n                                        .done(defer.resolve)\r\n                                        .fail(defer.reject)\r\n                                        .progress(defer.notify)\r\n                                } else {\r\n                                    var context = this === promise ? defer.promise() : this,\r\n                                        values = fn ? [returned] : arguments\r\n                                    defer[tuple[0] + \"With\"](context, values)\r\n                                }\r\n                            })\r\n                        })\r\n                        fns = null\r\n                    }).promise()\r\n                },\r\n\r\n                promise: function(obj) {\r\n                    return obj != null ? $.extend(obj, promise) : promise\r\n                }\r\n            },\r\n            deferred = {}\r\n\r\n        $.each(tuples, function(i, tuple) {\r\n            var list = tuple[2],\r\n                stateString = tuple[3]\r\n\r\n            promise[tuple[1]] = list.add\r\n\r\n            if (stateString) {\r\n                list.add(function() {\r\n                    state = stateString\r\n                }, tuples[i ^ 1][2].disable, tuples[2][2].lock)\r\n            }\r\n\r\n            deferred[tuple[0]] = function() {\r\n                deferred[tuple[0] + \"With\"](this === deferred ? promise : this, arguments)\r\n                return this\r\n            }\r\n            deferred[tuple[0] + \"With\"] = list.fireWith\r\n        })\r\n\r\n        promise.promise(deferred)\r\n        if (func) func.call(deferred, deferred)\r\n        return deferred\r\n    }\r\n\r\n    $.when = function(sub) {\r\n        var resolveValues = slice.call(arguments),\r\n            len = resolveValues.length,\r\n            i = 0,\r\n            remain = len !== 1 || (sub && $.isFunction(sub.promise)) ? len : 0,\r\n            deferred = remain === 1 ? sub : Deferred(),\r\n            progressValues, progressContexts, resolveContexts,\r\n            updateFn = function(i, ctx, val) {\r\n                return function(value) {\r\n                    ctx[i] = this\r\n                    val[i] = arguments.length > 1 ? slice.call(arguments) : value\r\n                    if (val === progressValues) {\r\n                        deferred.notifyWith(ctx, val)\r\n                    } else if (!(--remain)) {\r\n                        deferred.resolveWith(ctx, val)\r\n                    }\r\n                }\r\n            }\r\n\r\n        if (len > 1) {\r\n            progressValues = new Array(len)\r\n            progressContexts = new Array(len)\r\n            resolveContexts = new Array(len)\r\n            for (; i < len; ++i) {\r\n                if (resolveValues[i] && $.isFunction(resolveValues[i].promise)) {\r\n                    resolveValues[i].promise()\r\n                        .done(updateFn(i, resolveContexts, resolveValues))\r\n                        .fail(deferred.reject)\r\n                        .progress(updateFn(i, progressContexts, progressValues))\r\n                } else {\r\n                    --remain\r\n                }\r\n            }\r\n        }\r\n        if (!remain) deferred.resolveWith(resolveContexts, resolveValues)\r\n        return deferred.promise()\r\n    }\r\n\r\n    $.Deferred = Deferred\r\n\r\n    return $;\r\n\r\n});\r\n"]}