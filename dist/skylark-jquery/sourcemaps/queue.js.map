{"version":3,"sources":["queue.js"],"names":["define","langx","$","isArraylike","obj","length","type","isWindow","nodeType","Data","Object","defineProperty","this","cache","get","expando","Math","random","replace","core_rnotwhite","core_deletedIds","core_push","push","uid","accepts","owner","prototype","key","descriptor","unlock","value","defineProperties","e","extend","set","data","prop","isEmptyObject","undefined","access","stored","camelCase","remove","i","name","camel","isArray","concat","map","match","hasData","discard","data_priv","queue","elem","makeArray","dequeue","startLength","fn","shift","hooks","_queueHooks","next","unshift","stop","call","empty","fire","Callbacks","add","arr","results","ret","merge","first","second","l","j","setter","arguments","each","delay","time","fx","speeds","timeout","setTimeout","clearTimeout","clearQueue","promise","tmp","count","defer","Deferred","elements","resolve","resolveWith"],"mappings":"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","file":"../queue.js","sourcesContent":["define([\r\n    \"skylark-langx/langx\",\r\n    \"./core\",\r\n    \"./callbacks\"\r\n], function(langx, $) {\r\n\r\n // jQuery Data object\r\n  var rbrace = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,\r\n      rmultiDash = /([A-Z])/g,\r\n      expando = \"Sky\" + ( '1.0' + Math.random() ).replace( /\\D/g, \"\"),\r\n      optionsCache = {},\r\n      core_rnotwhite = /\\S+/g,\r\n      core_deletedIds = [],\r\n      core_push = core_deletedIds.push;\r\n\r\n// Convert String-formatted options into Object-formatted ones and store in cache\r\n  function createOptions( options ) {\r\n    var object = optionsCache[ options ] = {};\r\n    $.each( options.match( core_rnotwhite ) || [], function( _, flag ) {\r\n      object[ flag ] = true;\r\n    });\r\n    return object;\r\n  }\r\n\r\n  function isArraylike( obj ) {\r\n    var length = obj.length,\r\n        type = $.type( obj );\r\n\r\n    if ( $.isWindow( obj ) ) {\r\n      return false;\r\n    }\r\n\r\n    if ( obj.nodeType === 1 && length ) {\r\n      return true;\r\n    }\r\n\r\n    return type === \"array\" || type !== \"function\" &&\r\n        ( length === 0 ||\r\n            typeof length === \"number\" && length > 0 && ( length - 1 ) in obj );\r\n  }\r\n\r\n  \r\n\r\n  function Data() {\r\n    // Support: Android < 4,\r\n    // Old WebKit does not have Object.preventExtensions/freeze method,\r\n    // return new empty object instead with no [[set]] accessor\r\n    Object.defineProperty( this.cache = {}, 0, {\r\n      get: function() {\r\n        return {};\r\n      }\r\n    });\r\n\r\n    this.expando = expando + Math.random();\r\n  }\r\n\r\n  Data.uid = 1;\r\n\r\n  Data.accepts = function( owner ) {\r\n    // Accepts only:\r\n    //  - Node\r\n    //    - Node.ELEMENT_NODE\r\n    //    - Node.DOCUMENT_NODE\r\n    //  - Object\r\n    //    - Any\r\n    return owner.nodeType ?\r\n        owner.nodeType === 1 || owner.nodeType === 9 : true;\r\n  };\r\n\r\n  Data.prototype = {\r\n    key: function( owner ) {\r\n      // We can accept data for non-element nodes in modern browsers,\r\n      // but we should not, see #8335.\r\n      // Always return the key for a frozen object.\r\n      if ( !Data.accepts( owner ) ) {\r\n        return 0;\r\n      }\r\n\r\n      var descriptor = {},\r\n      // Check if the owner object already has a cache key\r\n          unlock = owner[ this.expando ];\r\n\r\n      // If not, create one\r\n      if ( !unlock ) {\r\n        unlock = Data.uid++;\r\n\r\n        // Secure it in a non-enumerable, non-writable property\r\n        try {\r\n          descriptor[ this.expando ] = { value: unlock };\r\n          Object.defineProperties( owner, descriptor );\r\n\r\n          // Support: Android < 4\r\n          // Fallback to a less secure definition\r\n        } catch ( e ) {\r\n          descriptor[ this.expando ] = unlock;\r\n          $.extend( owner, descriptor );\r\n        }\r\n      }\r\n\r\n      // Ensure the cache object\r\n      if ( !this.cache[ unlock ] ) {\r\n        this.cache[ unlock ] = {};\r\n      }\r\n\r\n      return unlock;\r\n    },\r\n    set: function( owner, data, value ) {\r\n      var prop,\r\n      // There may be an unlock assigned to this node,\r\n      // if there is no entry for this \"owner\", create one inline\r\n      // and set the unlock as though an owner entry had always existed\r\n          unlock = this.key( owner ),\r\n          cache = this.cache[ unlock ];\r\n\r\n      // Handle: [ owner, key, value ] args\r\n      if ( typeof data === \"string\" ) {\r\n        cache[ data ] = value;\r\n\r\n        // Handle: [ owner, { properties } ] args\r\n      } else {\r\n        // Fresh assignments by object are shallow copied\r\n        if ( $.isEmptyObject( cache ) ) {\r\n          $.extend( this.cache[ unlock ], data );\r\n          // Otherwise, copy the properties one-by-one to the cache object\r\n        } else {\r\n          for ( prop in data ) {\r\n            cache[ prop ] = data[ prop ];\r\n          }\r\n        }\r\n      }\r\n      return cache;\r\n    },\r\n    get: function( owner, key ) {\r\n      // Either a valid cache is found, or will be created.\r\n      // New caches will be created and the unlock returned,\r\n      // allowing direct access to the newly created\r\n      // empty data object. A valid owner object must be provided.\r\n      var cache = this.cache[ this.key( owner ) ];\r\n\r\n      return key === undefined ?\r\n          cache : cache[ key ];\r\n    },\r\n    access: function( owner, key, value ) {\r\n      var stored;\r\n      // In cases where either:\r\n      //\r\n      //   1. No key was specified\r\n      //   2. A string key was specified, but no value provided\r\n      //\r\n      // Take the \"read\" path and allow the get method to determine\r\n      // which value to return, respectively either:\r\n      //\r\n      //   1. The entire cache object\r\n      //   2. The data stored at the key\r\n      //\r\n      if ( key === undefined ||\r\n          ((key && typeof key === \"string\") && value === undefined) ) {\r\n\r\n        stored = this.get( owner, key );\r\n\r\n        return stored !== undefined ?\r\n            stored : this.get( owner, $.camelCase(key) );\r\n      }\r\n\r\n      // [*]When the key is not a string, or both a key and value\r\n      // are specified, set or extend (existing objects) with either:\r\n      //\r\n      //   1. An object of properties\r\n      //   2. A key and value\r\n      //\r\n      this.set( owner, key, value );\r\n\r\n      // Since the \"set\" path can have two possible entry points\r\n      // return the expected data based on which path was taken[*]\r\n      return value !== undefined ? value : key;\r\n    },\r\n    remove: function( owner, key ) {\r\n      var i, name, camel,\r\n          unlock = this.key( owner ),\r\n          cache = this.cache[ unlock ];\r\n\r\n      if ( key === undefined ) {\r\n        this.cache[ unlock ] = {};\r\n\r\n      } else {\r\n        // Support array or space separated string of keys\r\n        if ( $.isArray( key ) ) {\r\n          // If \"name\" is an array of keys...\r\n          // When data is initially created, via (\"key\", \"val\") signature,\r\n          // keys will be converted to camelCase.\r\n          // Since there is no way to tell _how_ a key was added, remove\r\n          // both plain key and camelCase key. #12786\r\n          // This will only penalize the array argument path.\r\n          name = key.concat( key.map( $.camelCase ) );\r\n        } else {\r\n          camel = $.camelCase( key );\r\n          // Try the string as a key before any manipulation\r\n          if ( key in cache ) {\r\n            name = [ key, camel ];\r\n          } else {\r\n            // If a key with the spaces exists, use it.\r\n            // Otherwise, create an array by matching non-whitespace\r\n            name = camel;\r\n            name = name in cache ?\r\n                [ name ] : ( name.match( core_rnotwhite ) || [] );\r\n          }\r\n        }\r\n\r\n        i = name.length;\r\n        while ( i-- ) {\r\n          delete cache[ name[ i ] ];\r\n        }\r\n      }\r\n    },\r\n    hasData: function( owner ) {\r\n      return !$.isEmptyObject(\r\n          this.cache[ owner[ this.expando ] ] || {}\r\n      );\r\n    },\r\n    discard: function( owner ) {\r\n      if ( owner[ this.expando ] ) {\r\n        delete this.cache[ owner[ this.expando ] ];\r\n      }\r\n    }\r\n  };\r\n\r\n  var data_priv = new Data();\r\n\r\n  $.extend($, {\r\n    queue: function( elem, type, data ) {\r\n      var queue;\r\n\r\n      if ( elem ) {\r\n        type = ( type || \"fx\" ) + \"queue\";\r\n        queue = data_priv.get( elem, type );\r\n\r\n        // Speed up dequeue by getting out quickly if this is just a lookup\r\n        if ( data ) {\r\n          if ( !queue || $.isArray( data ) ) {\r\n            queue = data_priv.access( elem, type, $.makeArray(data) );\r\n          } else {\r\n            queue.push( data );\r\n          }\r\n        }\r\n        return queue || [];\r\n      }\r\n    },\r\n\r\n    dequeue: function( elem, type ) {\r\n      type = type || \"fx\";\r\n\r\n      var queue = $.queue( elem, type ),\r\n          startLength = queue.length,\r\n          fn = queue.shift(),\r\n          hooks = $._queueHooks( elem, type ),\r\n          next = function() {\r\n            $.dequeue( elem, type );\r\n          };\r\n\r\n      // If the fx queue is dequeued, always remove the progress sentinel\r\n      if ( fn === \"inprogress\" ) {\r\n        fn = queue.shift();\r\n        startLength--;\r\n      }\r\n\r\n      if ( fn ) {\r\n\r\n        // Add a progress sentinel to prevent the fx queue from being\r\n        // automatically dequeued\r\n        if ( type === \"fx\" ) {\r\n          queue.unshift( \"inprogress\" );\r\n        }\r\n\r\n        // clear up the last queue stop function\r\n        delete hooks.stop;\r\n        fn.call( elem, next, hooks );\r\n      }\r\n\r\n      if ( !startLength && hooks ) {\r\n        hooks.empty.fire();\r\n      }\r\n    },\r\n\r\n    // not intended for public consumption - generates a queueHooks object, or returns the current one\r\n    _queueHooks: function( elem, type ) {\r\n      var key = type + \"queueHooks\";\r\n      return data_priv.get( elem, key ) || data_priv.access( elem, key, {\r\n        empty: $.Callbacks(\"once memory\").add(function() {\r\n          data_priv.remove( elem, [ type + \"queue\", key ] );\r\n        })\r\n      });\r\n    },\r\n\r\n    // array operations\r\n    makeArray: function( arr, results ) {\r\n      var ret = results || [];\r\n\r\n      if ( arr != null ) {\r\n        if ( isArraylike( Object(arr) ) ) {\r\n          $.merge( ret,\r\n              typeof arr === \"string\" ?\r\n                  [ arr ] : arr\r\n          );\r\n        } else {\r\n          core_push.call( ret, arr );\r\n        }\r\n      }\r\n\r\n      return ret;\r\n    },\r\n    merge: function( first, second ) {\r\n      var l = second.length,\r\n          i = first.length,\r\n          j = 0;\r\n\r\n      if ( typeof l === \"number\" ) {\r\n        for ( ; j < l; j++ ) {\r\n          first[ i++ ] = second[ j ];\r\n        }\r\n      } else {\r\n        while ( second[j] !== undefined ) {\r\n          first[ i++ ] = second[ j++ ];\r\n        }\r\n      }\r\n\r\n      first.length = i;\r\n\r\n      return first;\r\n    }\r\n  });\r\n\r\n  $.extend($.fn, {\r\n    queue: function( type, data ) {\r\n      var setter = 2;\r\n\r\n      if ( typeof type !== \"string\" ) {\r\n        data = type;\r\n        type = \"fx\";\r\n        setter--;\r\n      }\r\n\r\n      if ( arguments.length < setter ) {\r\n        return $.queue( this[0], type );\r\n      }\r\n\r\n      return data === undefined ?\r\n          this :\r\n          this.each(function() {\r\n            var queue = $.queue( this, type, data );\r\n\r\n            // ensure a hooks for this queue\r\n            $._queueHooks( this, type );\r\n\r\n            if ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\r\n              $.dequeue( this, type );\r\n            }\r\n          });\r\n    },\r\n    dequeue: function( type ) {\r\n      return this.each(function() {\r\n        $.dequeue( this, type );\r\n      });\r\n    },\r\n    // Based off of the plugin by Clint Helfers, with permission.\r\n    // http://blindsignals.com/index.php/2009/07/jquery-delay/\r\n    delay: function( time, type ) {\r\n      time = $.fx ? $.fx.speeds[ time ] || time : time;\r\n      type = type || \"fx\";\r\n\r\n      return this.queue( type, function( next, hooks ) {\r\n        var timeout = setTimeout( next, time );\r\n        hooks.stop = function() {\r\n          clearTimeout( timeout );\r\n        };\r\n      });\r\n    },\r\n    clearQueue: function( type ) {\r\n      return this.queue( type || \"fx\", [] );\r\n    },\r\n    // Get a promise resolved when queues of a certain type\r\n    // are emptied (fx is the type by default)\r\n    promise: function( type, obj ) {\r\n      var tmp,\r\n          count = 1,\r\n          defer = $.Deferred(),\r\n          elements = this,\r\n          i = this.length,\r\n          resolve = function() {\r\n            if ( !( --count ) ) {\r\n              defer.resolveWith( elements, [ elements ] );\r\n            }\r\n          };\r\n\r\n      if ( typeof type !== \"string\" ) {\r\n        obj = type;\r\n        type = undefined;\r\n      }\r\n      type = type || \"fx\";\r\n\r\n      while( i-- ) {\r\n        tmp = data_priv.get( elements[ i ], type + \"queueHooks\" );\r\n        if ( tmp && tmp.empty ) {\r\n          count++;\r\n          tmp.empty.add( resolve );\r\n        }\r\n      }\r\n      resolve();\r\n      return defer.promise( obj );\r\n    }\r\n  });\r\n\r\n  return $;\r\n\r\n});\r\n"]}