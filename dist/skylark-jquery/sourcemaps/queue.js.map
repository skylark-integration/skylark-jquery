{"version":3,"sources":["queue.js"],"names":["define","langx","$","expando","Math","random","replace","core_rnotwhite","core_push","push","Data","Object","defineProperty","this","cache","get","uid","accepts","owner","nodeType","prototype","key","descriptor","unlock","value","defineProperties","e","extend","set","data","prop","isEmptyObject","undefined","access","stored","camelCase","remove","i","name","camel","isArray","concat","map","match","length","hasData","discard","data_priv","queue","elem","type","makeArray","dequeue","startLength","fn","shift","hooks","_queueHooks","unshift","stop","call","empty","fire","Callbacks","add","arr","results","obj","ret","isWindow","merge","first","second","l","j","setter","arguments","each","delay","time","fx","speeds","next","timeout","setTimeout","clearTimeout","clearQueue","promise","tmp","count","defer","Deferred","elements","resolve","resolveWith"],"mappings":"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","file":"../queue.js","sourcesContent":["define([\r\n    \"skylark-langx/langx\",\r\n    \"./core\",\r\n    \"./callbacks\"\r\n], function(langx, $) {\r\n\r\n // jQuery Data object\r\n  var rbrace = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,\r\n      rmultiDash = /([A-Z])/g,\r\n      expando = \"Sky\" + ( '1.0' + Math.random() ).replace( /\\D/g, \"\"),\r\n      optionsCache = {},\r\n      core_rnotwhite = /\\S+/g,\r\n      core_deletedIds = [],\r\n      core_push = core_deletedIds.push;\r\n\r\n// Convert String-formatted options into Object-formatted ones and store in cache\r\n  function createOptions( options ) {\r\n    var object = optionsCache[ options ] = {};\r\n    $.each( options.match( core_rnotwhite ) || [], function( _, flag ) {\r\n      object[ flag ] = true;\r\n    });\r\n    return object;\r\n  }\r\n\r\n  function isArraylike( obj ) {\r\n    var length = obj.length,\r\n        type = $.type( obj );\r\n\r\n    if ( $.isWindow( obj ) ) {\r\n      return false;\r\n    }\r\n\r\n    if ( obj.nodeType === 1 && length ) {\r\n      return true;\r\n    }\r\n\r\n    return type === \"array\" || type !== \"function\" &&\r\n        ( length === 0 ||\r\n            typeof length === \"number\" && length > 0 && ( length - 1 ) in obj );\r\n  }\r\n\r\n  \r\n\r\n  function Data() {\r\n    // Support: Android < 4,\r\n    // Old WebKit does not have Object.preventExtensions/freeze method,\r\n    // return new empty object instead with no [[set]] accessor\r\n    Object.defineProperty( this.cache = {}, 0, {\r\n      get: function() {\r\n        return {};\r\n      }\r\n    });\r\n\r\n    this.expando = expando + Math.random();\r\n  }\r\n\r\n  Data.uid = 1;\r\n\r\n  Data.accepts = function( owner ) {\r\n    // Accepts only:\r\n    //  - Node\r\n    //    - Node.ELEMENT_NODE\r\n    //    - Node.DOCUMENT_NODE\r\n    //  - Object\r\n    //    - Any\r\n    return owner.nodeType ?\r\n        owner.nodeType === 1 || owner.nodeType === 9 : true;\r\n  };\r\n\r\n  Data.prototype = {\r\n    key: function( owner ) {\r\n      // We can accept data for non-element nodes in modern browsers,\r\n      // but we should not, see #8335.\r\n      // Always return the key for a frozen object.\r\n      if ( !Data.accepts( owner ) ) {\r\n        return 0;\r\n      }\r\n\r\n      var descriptor = {},\r\n      // Check if the owner object already has a cache key\r\n          unlock = owner[ this.expando ];\r\n\r\n      // If not, create one\r\n      if ( !unlock ) {\r\n        unlock = Data.uid++;\r\n\r\n        // Secure it in a non-enumerable, non-writable property\r\n        try {\r\n          descriptor[ this.expando ] = { value: unlock };\r\n          Object.defineProperties( owner, descriptor );\r\n\r\n          // Support: Android < 4\r\n          // Fallback to a less secure definition\r\n        } catch ( e ) {\r\n          descriptor[ this.expando ] = unlock;\r\n          $.extend( owner, descriptor );\r\n        }\r\n      }\r\n\r\n      // Ensure the cache object\r\n      if ( !this.cache[ unlock ] ) {\r\n        this.cache[ unlock ] = {};\r\n      }\r\n\r\n      return unlock;\r\n    },\r\n    set: function( owner, data, value ) {\r\n      var prop,\r\n      // There may be an unlock assigned to this node,\r\n      // if there is no entry for this \"owner\", create one inline\r\n      // and set the unlock as though an owner entry had always existed\r\n          unlock = this.key( owner ),\r\n          cache = this.cache[ unlock ];\r\n\r\n      // Handle: [ owner, key, value ] args\r\n      if ( typeof data === \"string\" ) {\r\n        cache[ data ] = value;\r\n\r\n        // Handle: [ owner, { properties } ] args\r\n      } else {\r\n        // Fresh assignments by object are shallow copied\r\n        if ( $.isEmptyObject( cache ) ) {\r\n          $.extend( this.cache[ unlock ], data );\r\n          // Otherwise, copy the properties one-by-one to the cache object\r\n        } else {\r\n          for ( prop in data ) {\r\n            cache[ prop ] = data[ prop ];\r\n          }\r\n        }\r\n      }\r\n      return cache;\r\n    },\r\n    get: function( owner, key ) {\r\n      // Either a valid cache is found, or will be created.\r\n      // New caches will be created and the unlock returned,\r\n      // allowing direct access to the newly created\r\n      // empty data object. A valid owner object must be provided.\r\n      var cache = this.cache[ this.key( owner ) ];\r\n\r\n      return key === undefined ?\r\n          cache : cache[ key ];\r\n    },\r\n    access: function( owner, key, value ) {\r\n      var stored;\r\n      // In cases where either:\r\n      //\r\n      //   1. No key was specified\r\n      //   2. A string key was specified, but no value provided\r\n      //\r\n      // Take the \"read\" path and allow the get method to determine\r\n      // which value to return, respectively either:\r\n      //\r\n      //   1. The entire cache object\r\n      //   2. The data stored at the key\r\n      //\r\n      if ( key === undefined ||\r\n          ((key && typeof key === \"string\") && value === undefined) ) {\r\n\r\n        stored = this.get( owner, key );\r\n\r\n        return stored !== undefined ?\r\n            stored : this.get( owner, $.camelCase(key) );\r\n      }\r\n\r\n      // [*]When the key is not a string, or both a key and value\r\n      // are specified, set or extend (existing objects) with either:\r\n      //\r\n      //   1. An object of properties\r\n      //   2. A key and value\r\n      //\r\n      this.set( owner, key, value );\r\n\r\n      // Since the \"set\" path can have two possible entry points\r\n      // return the expected data based on which path was taken[*]\r\n      return value !== undefined ? value : key;\r\n    },\r\n    remove: function( owner, key ) {\r\n      var i, name, camel,\r\n          unlock = this.key( owner ),\r\n          cache = this.cache[ unlock ];\r\n\r\n      if ( key === undefined ) {\r\n        this.cache[ unlock ] = {};\r\n\r\n      } else {\r\n        // Support array or space separated string of keys\r\n        if ( $.isArray( key ) ) {\r\n          // If \"name\" is an array of keys...\r\n          // When data is initially created, via (\"key\", \"val\") signature,\r\n          // keys will be converted to camelCase.\r\n          // Since there is no way to tell _how_ a key was added, remove\r\n          // both plain key and camelCase key. #12786\r\n          // This will only penalize the array argument path.\r\n          name = key.concat( key.map( $.camelCase ) );\r\n        } else {\r\n          camel = $.camelCase( key );\r\n          // Try the string as a key before any manipulation\r\n          if ( key in cache ) {\r\n            name = [ key, camel ];\r\n          } else {\r\n            // If a key with the spaces exists, use it.\r\n            // Otherwise, create an array by matching non-whitespace\r\n            name = camel;\r\n            name = name in cache ?\r\n                [ name ] : ( name.match( core_rnotwhite ) || [] );\r\n          }\r\n        }\r\n\r\n        i = name.length;\r\n        while ( i-- ) {\r\n          delete cache[ name[ i ] ];\r\n        }\r\n      }\r\n    },\r\n    hasData: function( owner ) {\r\n      return !$.isEmptyObject(\r\n          this.cache[ owner[ this.expando ] ] || {}\r\n      );\r\n    },\r\n    discard: function( owner ) {\r\n      if ( owner[ this.expando ] ) {\r\n        delete this.cache[ owner[ this.expando ] ];\r\n      }\r\n    }\r\n  };\r\n\r\n  var data_priv = new Data();\r\n\r\n  $.extend($, {\r\n    queue: function( elem, type, data ) {\r\n      var queue;\r\n\r\n      if ( elem ) {\r\n        type = ( type || \"fx\" ) + \"queue\";\r\n        queue = data_priv.get( elem, type );\r\n\r\n        // Speed up dequeue by getting out quickly if this is just a lookup\r\n        if ( data ) {\r\n          if ( !queue || $.isArray( data ) ) {\r\n            queue = data_priv.access( elem, type, $.makeArray(data) );\r\n          } else {\r\n            queue.push( data );\r\n          }\r\n        }\r\n        return queue || [];\r\n      }\r\n    },\r\n\r\n    dequeue: function( elem, type ) {\r\n      type = type || \"fx\";\r\n\r\n      var queue = $.queue( elem, type ),\r\n          startLength = queue.length,\r\n          fn = queue.shift(),\r\n          hooks = $._queueHooks( elem, type ),\r\n          next = function() {\r\n            $.dequeue( elem, type );\r\n          };\r\n\r\n      // If the fx queue is dequeued, always remove the progress sentinel\r\n      if ( fn === \"inprogress\" ) {\r\n        fn = queue.shift();\r\n        startLength--;\r\n      }\r\n\r\n      if ( fn ) {\r\n\r\n        // Add a progress sentinel to prevent the fx queue from being\r\n        // automatically dequeued\r\n        if ( type === \"fx\" ) {\r\n          queue.unshift( \"inprogress\" );\r\n        }\r\n\r\n        // clear up the last queue stop function\r\n        delete hooks.stop;\r\n        fn.call( elem, next, hooks );\r\n      }\r\n\r\n      if ( !startLength && hooks ) {\r\n        hooks.empty.fire();\r\n      }\r\n    },\r\n\r\n    // not intended for public consumption - generates a queueHooks object, or returns the current one\r\n    _queueHooks: function( elem, type ) {\r\n      var key = type + \"queueHooks\";\r\n      return data_priv.get( elem, key ) || data_priv.access( elem, key, {\r\n        empty: $.Callbacks(\"once memory\").add(function() {\r\n          data_priv.remove( elem, [ type + \"queue\", key ] );\r\n        })\r\n      });\r\n    },\r\n\r\n    // array operations\r\n    makeArray: function( arr, results ) {\r\n      var ret = results || [];\r\n\r\n      if ( arr != null ) {\r\n        if ( isArraylike( Object(arr) ) ) {\r\n          $.merge( ret,\r\n              typeof arr === \"string\" ?\r\n                  [ arr ] : arr\r\n          );\r\n        } else {\r\n          core_push.call( ret, arr );\r\n        }\r\n      }\r\n\r\n      return ret;\r\n    },\r\n    merge: function( first, second ) {\r\n      var l = second.length,\r\n          i = first.length,\r\n          j = 0;\r\n\r\n      if ( typeof l === \"number\" ) {\r\n        for ( ; j < l; j++ ) {\r\n          first[ i++ ] = second[ j ];\r\n        }\r\n      } else {\r\n        while ( second[j] !== undefined ) {\r\n          first[ i++ ] = second[ j++ ];\r\n        }\r\n      }\r\n\r\n      first.length = i;\r\n\r\n      return first;\r\n    }\r\n  });\r\n\r\n  $.extend($.fn, {\r\n    queue: function( type, data ) {\r\n      var setter = 2;\r\n\r\n      if ( typeof type !== \"string\" ) {\r\n        data = type;\r\n        type = \"fx\";\r\n        setter--;\r\n      }\r\n\r\n      if ( arguments.length < setter ) {\r\n        return $.queue( this[0], type );\r\n      }\r\n\r\n      return data === undefined ?\r\n          this :\r\n          this.each(function() {\r\n            var queue = $.queue( this, type, data );\r\n\r\n            // ensure a hooks for this queue\r\n            $._queueHooks( this, type );\r\n\r\n            if ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\r\n              $.dequeue( this, type );\r\n            }\r\n          });\r\n    },\r\n    dequeue: function( type ) {\r\n      return this.each(function() {\r\n        $.dequeue( this, type );\r\n      });\r\n    },\r\n    // Based off of the plugin by Clint Helfers, with permission.\r\n    // http://blindsignals.com/index.php/2009/07/jquery-delay/\r\n    delay: function( time, type ) {\r\n      time = $.fx ? $.fx.speeds[ time ] || time : time;\r\n      type = type || \"fx\";\r\n\r\n      return this.queue( type, function( next, hooks ) {\r\n        var timeout = setTimeout( next, time );\r\n        hooks.stop = function() {\r\n          clearTimeout( timeout );\r\n        };\r\n      });\r\n    },\r\n    clearQueue: function( type ) {\r\n      return this.queue( type || \"fx\", [] );\r\n    },\r\n    // Get a promise resolved when queues of a certain type\r\n    // are emptied (fx is the type by default)\r\n    promise: function( type, obj ) {\r\n      var tmp,\r\n          count = 1,\r\n          defer = $.Deferred(),\r\n          elements = this,\r\n          i = this.length,\r\n          resolve = function() {\r\n            if ( !( --count ) ) {\r\n              defer.resolveWith( elements, [ elements ] );\r\n            }\r\n          };\r\n\r\n      if ( typeof type !== \"string\" ) {\r\n        obj = type;\r\n        type = undefined;\r\n      }\r\n      type = type || \"fx\";\r\n\r\n      while( i-- ) {\r\n        tmp = data_priv.get( elements[ i ], type + \"queueHooks\" );\r\n        if ( tmp && tmp.empty ) {\r\n          count++;\r\n          tmp.empty.add( resolve );\r\n        }\r\n      }\r\n      resolve();\r\n      return defer.promise( obj );\r\n    }\r\n  });\r\n\r\n  return $;\r\n\r\n});\r\n"]}