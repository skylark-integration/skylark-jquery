{"version":3,"sources":["old/deferred.js"],"names":["define","$","slice","Array","prototype","Deferred","func","tuples","Callbacks","once","memory","state","promise","always","deferred","done","arguments","fail","this","then","fns","defer","each","i","tuple","fn","isFunction","returned","apply","resolve","reject","progress","notify","context","values","obj","extend","pipe","list","stateString","add","disable","lock","fireWith","call","when","sub","progressValues","progressContexts","resolveContexts","resolveValues","len","length","remain","updateFn","ctx","val","value","notifyWith","resolveWith"],"mappings":"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","file":"../../old/deferred.js","sourcesContent":["define([\r\n    \"./core\"\r\n], function($) {\r\n\r\n    /*\r\n        (function ($) {\r\n            $.Deferred = async.Deferred;\r\n            $.when = async.when;\r\n        })(Zepto);\r\n    */\r\n\r\n    //     This module is borrow from zepto.deferred.js\r\n    //     (c) 2010-2014 Thomas Fuchs\r\n    //     Zepto.js may be freely distributed under the MIT license.\r\n    //\r\n    //     Some code (c) 2005, 2013 jQuery Foundation, Inc. and other contributors\r\n\r\n    var slice = Array.prototype.slice\r\n\r\n    function Deferred(func) {\r\n        var tuples = [\r\n                // action, add listener, listener list, final state\r\n                [\"resolve\", \"done\", $.Callbacks({ once: 1, memory: 1 }), \"resolved\"],\r\n                [\"reject\", \"fail\", $.Callbacks({ once: 1, memory: 1 }), \"rejected\"],\r\n                [\"notify\", \"progress\", $.Callbacks({ memory: 1 })]\r\n            ],\r\n            state = \"pending\",\r\n            promise = {\r\n                state: function() {\r\n                    return state\r\n                },\r\n                always: function() {\r\n                    deferred.done(arguments).fail(arguments)\r\n                    return this\r\n                },\r\n                then: function( /* fnDone [, fnFailed [, fnProgress]] */ ) {\r\n                    var fns = arguments\r\n                    return Deferred(function(defer) {\r\n                        $.each(tuples, function(i, tuple) {\r\n                            var fn = $.isFunction(fns[i]) && fns[i]\r\n                            deferred[tuple[1]](function() {\r\n                                var returned = fn && fn.apply(this, arguments)\r\n                                if (returned && $.isFunction(returned.promise)) {\r\n                                    returned.promise()\r\n                                        .done(defer.resolve)\r\n                                        .fail(defer.reject)\r\n                                        .progress(defer.notify)\r\n                                } else {\r\n                                    var context = this === promise ? defer.promise() : this,\r\n                                        values = fn ? [returned] : arguments\r\n                                    defer[tuple[0] + \"With\"](context, values)\r\n                                }\r\n                            })\r\n                        })\r\n                        fns = null\r\n                    }).promise()\r\n                },\r\n\r\n                promise: function(obj) {\r\n                    return obj != null ? $.extend(obj, promise) : promise\r\n                }\r\n            },\r\n            deferred = {};\r\n\r\n        promise.pipe = promise.then;\r\n\r\n        $.each(tuples, function(i, tuple) {\r\n            var list = tuple[2],\r\n                stateString = tuple[3]\r\n\r\n            promise[tuple[1]] = list.add\r\n\r\n            if (stateString) {\r\n                list.add(function() {\r\n                    state = stateString\r\n                }, tuples[i ^ 1][2].disable, tuples[2][2].lock)\r\n            }\r\n\r\n            deferred[tuple[0]] = function() {\r\n                deferred[tuple[0] + \"With\"](this === deferred ? promise : this, arguments)\r\n                return this\r\n            }\r\n            deferred[tuple[0] + \"With\"] = list.fireWith\r\n        })\r\n\r\n        promise.promise(deferred)\r\n        if (func) func.call(deferred, deferred)\r\n        return deferred\r\n    }\r\n\r\n    $.when = function(sub) {\r\n        var resolveValues = slice.call(arguments),\r\n            len = resolveValues.length,\r\n            i = 0,\r\n            remain = len !== 1 || (sub && $.isFunction(sub.promise)) ? len : 0,\r\n            deferred = remain === 1 ? sub : Deferred(),\r\n            progressValues, progressContexts, resolveContexts,\r\n            updateFn = function(i, ctx, val) {\r\n                return function(value) {\r\n                    ctx[i] = this\r\n                    val[i] = arguments.length > 1 ? slice.call(arguments) : value\r\n                    if (val === progressValues) {\r\n                        deferred.notifyWith(ctx, val)\r\n                    } else if (!(--remain)) {\r\n                        deferred.resolveWith(ctx, val)\r\n                    }\r\n                }\r\n            }\r\n\r\n        if (len > 1) {\r\n            progressValues = new Array(len)\r\n            progressContexts = new Array(len)\r\n            resolveContexts = new Array(len)\r\n            for (; i < len; ++i) {\r\n                if (resolveValues[i] && $.isFunction(resolveValues[i].promise)) {\r\n                    resolveValues[i].promise()\r\n                        .done(updateFn(i, resolveContexts, resolveValues))\r\n                        .fail(deferred.reject)\r\n                        .progress(updateFn(i, progressContexts, progressValues))\r\n                } else {\r\n                    --remain\r\n                }\r\n            }\r\n        }\r\n        if (!remain) deferred.resolveWith(resolveContexts, resolveValues)\r\n        return deferred.promise()\r\n    }\r\n\r\n    $.Deferred = Deferred\r\n\r\n    return $;\r\n\r\n});\r\n"]}